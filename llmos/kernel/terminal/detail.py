"""
Cron Detail Panel - Right panel of the terminal.

Shows detailed information about the selected cron:
- Current thinking process
- Suggestions and predictions
- Activity log
- Interactive chat (for user's own cron)
"""

from typing import Dict, Any, Optional, List

from .models import (
    CronDetailView,
    ThinkingProcess,
    Suggestion,
    SuggestionType,
    ActivityEntry
)


class CronDetailPanel:
    """
    Renders and manages the cron detail view.

    The panel shows different sections based on the selected cron
    and whether the user can interact with it.
    """

    def __init__(self, current_user_id: str):
        self.current_user_id = current_user_id
        self.scroll_offset = 0

    def build_detail_view(
        self,
        cron_id: str,
        cron_status: Dict[str, Any],
        activity_events: List[Dict[str, Any]],
        suggestions: List[Dict[str, Any]]
    ) -> CronDetailView:
        """
        Build the detail view for a cron.

        Args:
            cron_id: ID of the cron
            cron_status: Status dict from the cron
            activity_events: Recent events for this cron
            suggestions: Suggestions generated by this cron

        Returns:
            CronDetailView object
        """
        cron_type = cron_id.split(":")[0] if ":" in cron_id else "system"
        owner_id = cron_id.split(":")[1] if ":" in cron_id else "system"

        # Determine if interactive
        is_interactive = (cron_type == "user" and owner_id == self.current_user_id)

        # Build display name
        type_icons = {"system": "ğŸ§ ", "team": "ğŸ‘¥", "user": "ğŸ‘¤"}
        display_name = f"{type_icons.get(cron_type, 'ğŸ¤–')} {cron_type.title()}Cron"
        if owner_id != "system":
            display_name += f":{owner_id}"
        if is_interactive:
            display_name += " [YOU]"

        # Build thinking process
        thinking = None
        if cron_status.get("current_thinking"):
            thinking = ThinkingProcess(
                current_action=cron_status["current_thinking"].get("action", "Idle"),
                analyzed_items=cron_status["current_thinking"].get("analyzed", []),
                found_patterns=cron_status["current_thinking"].get("patterns", []),
                considering=cron_status["current_thinking"].get("considering", []),
                cross_references=cron_status["current_thinking"].get("cross_refs", [])
            )

        # Build suggestions
        parsed_suggestions = []
        for s in suggestions:
            stype = self._parse_suggestion_type(s.get("type", "recommendation"))
            parsed_suggestions.append(Suggestion(
                suggestion_type=stype,
                title=s.get("title", ""),
                description=s.get("description", ""),
                confidence=s.get("confidence", 0.0),
                source=s.get("source"),
                action_id=s.get("action_id")
            ))

        # Build activity log
        activity_log = []
        for event in activity_events[:10]:  # Last 10 events
            icon = self._get_event_icon(event.get("event_type", ""))
            activity_log.append(ActivityEntry(
                timestamp=event.get("timestamp", ""),
                icon=icon,
                message=event.get("title", ""),
                event_id=event.get("event_id")
            ))

        return CronDetailView(
            cron_id=cron_id,
            cron_type=cron_type,
            display_name=display_name,
            is_interactive=is_interactive,
            thinking=thinking,
            suggestions=parsed_suggestions,
            activity_log=activity_log
        )

    def _parse_suggestion_type(self, type_str: str) -> SuggestionType:
        """Parse suggestion type string"""
        type_map = {
            "immediate": SuggestionType.IMMEDIATE,
            "recommendation": SuggestionType.RECOMMENDATION,
            "prediction": SuggestionType.PREDICTION,
            "creative": SuggestionType.CREATIVE
        }
        return type_map.get(type_str.lower(), SuggestionType.RECOMMENDATION)

    def _get_event_icon(self, event_type: str) -> str:
        """Get icon for event type"""
        icons = {
            "cron_started": "â–¶ï¸",
            "cron_stopped": "â¹ï¸",
            "cron_cycle_end": "âœ…",
            "artifact_created": "ğŸ“„",
            "artifact_evolved": "âœ¨",
            "artifact_promoted": "ğŸš€",
            "artifact_deleted": "ğŸ—‘ï¸",
            "proposal_created": "ğŸ“",
            "insight_generated": "ğŸ’¡",
            "suggestion_created": "ğŸ¯",
            "system_alert": "âš ï¸"
        }
        return icons.get(event_type.lower(), "ğŸ“Œ")

    def render(self, view: CronDetailView, width: int = 50, height: int = 30) -> List[str]:
        """
        Render the detail panel.

        Args:
            view: CronDetailView to render
            width: Width of the panel
            height: Height of the panel

        Returns:
            List of formatted lines
        """
        lines = []

        # Header
        lines.append(f"ğŸ“‹ CRON DETAILS: {view.display_name}")
        lines.append("â”€" * (width - 2))
        lines.append("")

        # Thinking Process Section
        lines.append("â”Œâ”€ Current Thinking " + "â”€" * (width - 22) + "â”")
        if view.thinking:
            thinking_lines = view.thinking.format().split("\n")
            for tl in thinking_lines:
                lines.append(f"â”‚ {tl:<{width - 4}} â”‚")
        else:
            lines.append(f"â”‚ {'âœ… Idle - no active analysis':<{width - 4}} â”‚")
        lines.append("â””" + "â”€" * (width - 2) + "â”˜")
        lines.append("")

        # Suggestions Section
        lines.append("â”Œâ”€ Suggested Next Steps " + "â”€" * (width - 26) + "â”")
        if view.suggestions:
            for s in view.suggestions[:4]:  # Max 4 suggestions
                suggestion_lines = s.format().split("\n")
                for sl in suggestion_lines:
                    lines.append(f"â”‚ {sl:<{width - 4}} â”‚")
                lines.append(f"â”‚ {'':<{width - 4}} â”‚")
        else:
            lines.append(f"â”‚ {'No suggestions at this time':<{width - 4}} â”‚")
        lines.append("â””" + "â”€" * (width - 2) + "â”˜")
        lines.append("")

        # Activity Log Section
        lines.append("â”Œâ”€ Recent Activity " + "â”€" * (width - 21) + "â”")
        if view.activity_log:
            for entry in view.activity_log[:5]:  # Max 5 entries
                entry_line = entry.format()
                lines.append(f"â”‚ {entry_line:<{width - 4}} â”‚")
        else:
            lines.append(f"â”‚ {'No recent activity':<{width - 4}} â”‚")
        lines.append("â””" + "â”€" * (width - 2) + "â”˜")
        lines.append("")

        # Interaction Section
        if view.is_interactive:
            lines.append("â”Œâ”€ Chat with Your Cron " + "â”€" * (width - 25) + "â”")
            # Show chat history
            for msg in view.chat_history[-3:]:  # Last 3 messages
                role = "You" if msg["role"] == "user" else "ğŸ¤– Cron"
                lines.append(f"â”‚ {role}: {msg['content'][:width - 12]:<{width - 10}} â”‚")
            lines.append(f"â”‚ {'':<{width - 4}} â”‚")
            lines.append(f"â”‚ {'> _':<{width - 4}} â”‚")
            lines.append("â””" + "â”€" * (width - 2) + "â”˜")
        else:
            lines.append("â”Œâ”€ " + view.display_name + " Activity " + "â”€" * (width - len(view.display_name) - 15) + "â”")
            lines.append(f"â”‚ {'ğŸ”’ READ-ONLY VIEW':<{width - 4}} â”‚")
            lines.append(f"â”‚ {'':<{width - 4}} â”‚")
            lines.append(f"â”‚ {'[You can view but not interact with this cron]':<{width - 4}} â”‚")
            lines.append("â””" + "â”€" * (width - 2) + "â”˜")

        # Pad to height
        while len(lines) < height:
            lines.append("")

        return lines[:height]

    def scroll_up(self):
        """Scroll up in the detail view"""
        if self.scroll_offset > 0:
            self.scroll_offset -= 1

    def scroll_down(self, content_height: int, view_height: int):
        """Scroll down in the detail view"""
        max_scroll = max(0, content_height - view_height)
        if self.scroll_offset < max_scroll:
            self.scroll_offset += 1
