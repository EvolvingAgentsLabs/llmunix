"""
Sentience Cron System for LLM OS

The Sentience Crons are scheduled background processes that analyze and evolve
the system's artifacts (traces, tools, agents). They operate at three levels:

- **UserCron**: Personal evolution for a single user's artifacts
- **TeamCron**: Shared evolution for team artifacts, can see patterns across users
- **SystemCron**: Global evolution, controls other crons, system-wide optimization

Each cron is a "smart entity" that:
1. Analyzes artifacts in its accessible volumes
2. Generates insights and improvement suggestions
3. Evolves artifacts (summarize traces, refine tools, improve agents)
4. Notifies users of its activity

The cron hierarchy:
```
                    ┌─────────────────┐
                    │   SystemCron    │
                    │  (full access)  │
                    └────────┬────────┘
                             │ controls
              ┌──────────────┼──────────────┐
              │              │              │
       ┌──────▼─────┐ ┌──────▼─────┐ ┌──────▼─────┐
       │  TeamCron  │ │  TeamCron  │ │  TeamCron  │
       │  (team A)  │ │  (team B)  │ │  (team C)  │
       └──────┬─────┘ └──────┬─────┘ └──────┬─────┘
              │              │              │
        ┌─────┼─────┐  ┌─────┼─────┐  ┌─────┼─────┐
        │     │     │  │     │     │  │     │     │
       User  User  User ...  ...  ... ...  ...  ...
       Cron  Cron  Cron
```
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, Callable
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
import asyncio
import json
import logging

from .volumes import (
    Volume, VolumeManager, VolumeType, ArtifactType, ArtifactAction, ArtifactChange
)
from .observability import ObservabilityHub, EventType, Severity

logger = logging.getLogger(__name__)


class CronLevel(Enum):
    """Levels of sentience crons"""
    USER = "user"
    TEAM = "team"
    SYSTEM = "system"


class TaskType(Enum):
    """Types of cron tasks"""
    ANALYZE_TRACES = "analyze_traces"
    SUMMARIZE_TRACES = "summarize_traces"
    ANALYZE_TOOLS = "analyze_tools"
    EVOLVE_TOOLS = "evolve_tools"
    ANALYZE_AGENTS = "analyze_agents"
    IMPROVE_AGENTS = "improve_agents"
    GENERATE_INSIGHTS = "generate_insights"
    SUGGEST_IMPROVEMENTS = "suggest_improvements"
    CLEANUP_OLD_ARTIFACTS = "cleanup_old_artifacts"
    PROMOTE_ARTIFACTS = "promote_artifacts"


@dataclass
class CronTask:
    """A task executed by a cron"""
    task_id: str
    task_type: TaskType
    started_at: str
    completed_at: Optional[str] = None
    status: str = "running"  # running, completed, failed
    artifacts_processed: int = 0
    artifacts_created: int = 0
    artifacts_modified: int = 0
    artifacts_deleted: int = 0
    summary: str = ""
    details: Dict[str, Any] = field(default_factory=dict)

    def as_dict(self) -> Dict[str, Any]:
        return {
            "task_id": self.task_id,
            "task_type": self.task_type.value,
            "started_at": self.started_at,
            "completed_at": self.completed_at,
            "status": self.status,
            "artifacts_processed": self.artifacts_processed,
            "artifacts_created": self.artifacts_created,
            "artifacts_modified": self.artifacts_modified,
            "artifacts_deleted": self.artifacts_deleted,
            "summary": self.summary,
            "details": self.details
        }


@dataclass
class CronNotification:
    """A notification from a cron to users"""
    notification_id: str
    cron_level: CronLevel
    cron_owner: str
    timestamp: str
    title: str
    message: str
    importance: str = "info"  # info, suggestion, warning, action_required
    related_artifacts: List[str] = field(default_factory=list)
    acknowledged: bool = False

    def as_dict(self) -> Dict[str, Any]:
        return {
            "notification_id": self.notification_id,
            "cron_level": self.cron_level.value,
            "cron_owner": self.cron_owner,
            "timestamp": self.timestamp,
            "title": self.title,
            "message": self.message,
            "importance": self.importance,
            "related_artifacts": self.related_artifacts,
            "acknowledged": self.acknowledged
        }


@dataclass
class Insight:
    """An insight generated by analyzing artifacts"""
    insight_id: str
    insight_type: str  # pattern, optimization, anomaly, opportunity
    title: str
    description: str
    evidence: List[str]  # artifact IDs that support this insight
    confidence: float  # 0.0 to 1.0
    actionable: bool
    suggested_action: Optional[str] = None
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())

    def as_dict(self) -> Dict[str, Any]:
        return {
            "insight_id": self.insight_id,
            "insight_type": self.insight_type,
            "title": self.title,
            "description": self.description,
            "evidence": self.evidence,
            "confidence": self.confidence,
            "actionable": self.actionable,
            "suggested_action": self.suggested_action,
            "created_at": self.created_at
        }

    def to_markdown(self) -> str:
        """Convert insight to markdown format for storage"""
        lines = [
            "---",
            f"insight_id: {self.insight_id}",
            f"insight_type: {self.insight_type}",
            f"confidence: {self.confidence}",
            f"actionable: {self.actionable}",
            f"created_at: {self.created_at}",
            "---",
            "",
            f"# {self.title}",
            "",
            self.description,
            "",
            "## Evidence",
            ""
        ]
        for e in self.evidence:
            lines.append(f"- `{e}`")

        if self.suggested_action:
            lines.extend([
                "",
                "## Suggested Action",
                "",
                self.suggested_action
            ])

        return "\n".join(lines)


@dataclass
class Suggestion:
    """A suggestion for improvement"""
    suggestion_id: str
    suggestion_type: str  # new_tool, refactor_agent, consolidate_traces, etc.
    title: str
    description: str
    priority: float  # 0.0 to 1.0
    estimated_benefit: str
    implementation_hint: Optional[str] = None
    related_artifacts: List[str] = field(default_factory=list)
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    status: str = "pending"  # pending, accepted, rejected, implemented

    def as_dict(self) -> Dict[str, Any]:
        return {
            "suggestion_id": self.suggestion_id,
            "suggestion_type": self.suggestion_type,
            "title": self.title,
            "description": self.description,
            "priority": self.priority,
            "estimated_benefit": self.estimated_benefit,
            "implementation_hint": self.implementation_hint,
            "related_artifacts": self.related_artifacts,
            "created_at": self.created_at,
            "status": self.status
        }

    def to_markdown(self) -> str:
        """Convert suggestion to markdown format for storage"""
        lines = [
            "---",
            f"suggestion_id: {self.suggestion_id}",
            f"suggestion_type: {self.suggestion_type}",
            f"priority: {self.priority}",
            f"status: {self.status}",
            f"created_at: {self.created_at}",
            "---",
            "",
            f"# {self.title}",
            "",
            self.description,
            "",
            f"**Priority**: {self.priority:.2f}",
            f"**Estimated Benefit**: {self.estimated_benefit}",
            ""
        ]

        if self.implementation_hint:
            lines.extend([
                "## Implementation Hint",
                "",
                self.implementation_hint,
                ""
            ])

        if self.related_artifacts:
            lines.extend([
                "## Related Artifacts",
                ""
            ])
            for a in self.related_artifacts:
                lines.append(f"- `{a}`")

        return "\n".join(lines)


class SentienceCron(ABC):
    """
    Base class for sentience crons.

    A sentience cron is a scheduled background process that analyzes and
    evolves artifacts in the system. It's a "smart entity" that lives
    alongside users and helps improve the system over time.
    """

    def __init__(
        self,
        cron_level: CronLevel,
        owner_id: str,
        volume_manager: VolumeManager,
        schedule_interval_secs: float = 3600.0,  # Default: 1 hour
        llm_callback: Optional[Callable[[str], str]] = None,
        observability_hub: Optional[ObservabilityHub] = None
    ):
        self.cron_level = cron_level
        self.owner_id = owner_id
        self.volume_manager = volume_manager
        self.schedule_interval_secs = schedule_interval_secs
        self.llm_callback = llm_callback
        self.observability_hub = observability_hub

        # State
        self._running = False
        self._task: Optional[asyncio.Task] = None
        self._last_run: Optional[datetime] = None
        self._task_history: List[CronTask] = []
        self._notifications: List[CronNotification] = []
        self._max_history = 100

        # Volumes accessible to this cron
        self._volumes: Dict[str, Volume] = {}

    @property
    def cron_id(self) -> str:
        """Get unique cron identifier"""
        if self.cron_level == CronLevel.SYSTEM:
            return "system"
        return f"{self.cron_level.value}:{self.owner_id}"

    @abstractmethod
    def _setup_volumes(self):
        """Set up volume access based on cron level"""
        pass

    @abstractmethod
    async def _run_analysis(self) -> List[CronTask]:
        """Run the cron's analysis tasks"""
        pass

    def _generate_task_id(self, task_type: TaskType) -> str:
        """Generate a unique task ID"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"{self.cron_level.value}_{self.owner_id}_{task_type.value}_{timestamp}"

    def _generate_notification_id(self) -> str:
        """Generate a unique notification ID"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
        return f"notif_{self.cron_level.value}_{timestamp}"

    def _create_notification(
        self,
        title: str,
        message: str,
        importance: str = "info",
        related_artifacts: Optional[List[str]] = None
    ) -> CronNotification:
        """Create and store a notification"""
        notification = CronNotification(
            notification_id=self._generate_notification_id(),
            cron_level=self.cron_level,
            cron_owner=self.owner_id,
            timestamp=datetime.now().isoformat(),
            title=title,
            message=message,
            importance=importance,
            related_artifacts=related_artifacts or []
        )
        self._notifications.append(notification)

        # Trim old notifications
        if len(self._notifications) > self._max_history:
            self._notifications = self._notifications[-self._max_history:]

        return notification

    async def _run_loop(self):
        """Main cron loop"""
        logger.info(f"[{self.cron_level.value}Cron:{self.owner_id}] Starting")

        # Record cron started
        if self.observability_hub:
            self.observability_hub.record_cron_started(self.cron_id, self.cron_level.value)

        while self._running:
            try:
                cycle_start = datetime.now()

                # Run analysis
                tasks = await self._run_analysis()

                # Store task history
                self._task_history.extend(tasks)
                if len(self._task_history) > self._max_history:
                    self._task_history = self._task_history[-self._max_history:]

                self._last_run = datetime.now()

                # Record cycle completion
                if self.observability_hub:
                    duration = (datetime.now() - cycle_start).total_seconds()
                    tasks_completed = sum(1 for t in tasks if t.status == "completed")
                    self.observability_hub.record_cycle(self.cron_id, tasks_completed, duration)

                # Wait for next interval
                await asyncio.sleep(self.schedule_interval_secs)

            except asyncio.CancelledError:
                logger.info(f"[{self.cron_level.value}Cron:{self.owner_id}] Cancelled")
                break
            except Exception as e:
                logger.error(f"[{self.cron_level.value}Cron:{self.owner_id}] Error: {e}")
                if self.observability_hub:
                    self.observability_hub.record_alert(
                        self.cron_id,
                        f"Cron Error",
                        str(e),
                        severity=Severity.ERROR
                    )
                await asyncio.sleep(60)  # Wait a bit before retrying

        # Record cron stopped
        if self.observability_hub:
            self.observability_hub.record_cron_stopped(self.cron_id, self.cron_level.value)

        logger.info(f"[{self.cron_level.value}Cron:{self.owner_id}] Stopped")

    # =========================================================================
    # PUBLIC API
    # =========================================================================

    def start(self):
        """Start the cron"""
        if self._running:
            return

        self._setup_volumes()
        self._running = True
        self._task = asyncio.create_task(self._run_loop())

    def stop(self):
        """Stop the cron"""
        self._running = False
        if self._task:
            self._task.cancel()
            self._task = None

    async def run_now(self) -> List[CronTask]:
        """Run the cron immediately (outside of schedule)"""
        self._setup_volumes()
        return await self._run_analysis()

    def get_status(self) -> Dict[str, Any]:
        """Get cron status"""
        return {
            "cron_level": self.cron_level.value,
            "owner_id": self.owner_id,
            "running": self._running,
            "last_run": self._last_run.isoformat() if self._last_run else None,
            "schedule_interval_secs": self.schedule_interval_secs,
            "task_history_count": len(self._task_history),
            "notification_count": len(self._notifications),
            "volumes": list(self._volumes.keys())
        }

    def get_task_history(self, limit: int = 20) -> List[Dict[str, Any]]:
        """Get recent task history"""
        return [t.as_dict() for t in self._task_history[-limit:]]

    def get_notifications(
        self,
        unacknowledged_only: bool = False,
        limit: int = 50
    ) -> List[Dict[str, Any]]:
        """Get notifications"""
        notifications = self._notifications
        if unacknowledged_only:
            notifications = [n for n in notifications if not n.acknowledged]
        return [n.as_dict() for n in notifications[-limit:]]

    def acknowledge_notification(self, notification_id: str) -> bool:
        """Acknowledge a notification"""
        for n in self._notifications:
            if n.notification_id == notification_id:
                n.acknowledged = True
                return True
        return False

    def get_activity_summary(self) -> str:
        """Get a human-readable summary of recent activity"""
        if not self._task_history:
            return f"[{self.cron_level.value}Cron:{self.owner_id}] No activity yet."

        recent = self._task_history[-5:]
        lines = [
            f"## {self.cron_level.value.title()} Cron Activity ({self.owner_id})",
            ""
        ]

        for task in recent:
            status_emoji = "✓" if task.status == "completed" else "✗"
            lines.append(
                f"- {status_emoji} **{task.task_type.value}** ({task.started_at[:10]}): "
                f"{task.summary or 'No summary'}"
            )

        total_processed = sum(t.artifacts_processed for t in recent)
        total_created = sum(t.artifacts_created for t in recent)
        total_modified = sum(t.artifacts_modified for t in recent)

        lines.extend([
            "",
            f"**Recent totals**: {total_processed} processed, "
            f"{total_created} created, {total_modified} modified"
        ])

        return "\n".join(lines)


class UserCron(SentienceCron):
    """
    User-level sentience cron.

    Access:
    - Read/Write: User volume
    - Read: Team volume (for context)

    Responsibilities:
    - Analyze user's traces for patterns
    - Summarize old traces to save space
    - Suggest tool improvements based on usage
    - Identify opportunities for agent refinement
    """

    def __init__(
        self,
        user_id: str,
        team_id: Optional[str],
        volume_manager: VolumeManager,
        schedule_interval_secs: float = 1800.0,  # 30 minutes
        llm_callback: Optional[Callable[[str], str]] = None,
        observability_hub: Optional[ObservabilityHub] = None
    ):
        super().__init__(
            cron_level=CronLevel.USER,
            owner_id=user_id,
            volume_manager=volume_manager,
            schedule_interval_secs=schedule_interval_secs,
            llm_callback=llm_callback,
            observability_hub=observability_hub
        )
        self.user_id = user_id
        self.team_id = team_id

    def _setup_volumes(self):
        """Set up user and team volumes"""
        self._volumes = self.volume_manager.get_volumes_for_cron(
            cron_level="user",
            user_id=self.user_id,
            team_id=self.team_id
        )

    async def _run_analysis(self) -> List[CronTask]:
        """Run user-level analysis"""
        tasks = []

        # Task 1: Analyze traces
        task = await self._analyze_traces()
        tasks.append(task)

        # Task 2: Generate insights
        task = await self._generate_insights()
        tasks.append(task)

        # Task 3: Suggest improvements
        task = await self._suggest_improvements()
        tasks.append(task)

        return tasks

    async def _analyze_traces(self) -> CronTask:
        """Analyze user's traces for patterns"""
        task = CronTask(
            task_id=self._generate_task_id(TaskType.ANALYZE_TRACES),
            task_type=TaskType.ANALYZE_TRACES,
            started_at=datetime.now().isoformat()
        )

        try:
            user_volume = self._volumes.get("user")
            if not user_volume:
                task.status = "failed"
                task.summary = "No user volume available"
                return task

            traces = user_volume.list_artifacts(ArtifactType.TRACE)
            task.artifacts_processed = len(traces)

            # Analyze for patterns (simplified - would use LLM in production)
            patterns = self._detect_patterns(user_volume, traces)

            task.status = "completed"
            task.summary = f"Analyzed {len(traces)} traces, found {len(patterns)} patterns"
            task.details = {"patterns": patterns}

        except Exception as e:
            task.status = "failed"
            task.summary = str(e)

        task.completed_at = datetime.now().isoformat()
        return task

    def _detect_patterns(self, volume: Volume, trace_ids: List[str]) -> List[Dict[str, Any]]:
        """Detect patterns in traces (simplified implementation)"""
        patterns = []

        # Group traces by goal prefix
        goal_groups: Dict[str, int] = {}
        for trace_id in trace_ids[:50]:  # Limit for performance
            # Extract goal from trace ID (simplified)
            parts = trace_id.split("_")
            if len(parts) > 1:
                goal_prefix = parts[0]
                goal_groups[goal_prefix] = goal_groups.get(goal_prefix, 0) + 1

        # Find repeated patterns
        for prefix, count in goal_groups.items():
            if count >= 3:
                patterns.append({
                    "type": "repeated_goal",
                    "prefix": prefix,
                    "count": count,
                    "suggestion": f"Consider creating a dedicated tool for '{prefix}' tasks"
                })

        return patterns

    async def _generate_insights(self) -> CronTask:
        """Generate insights from user's artifacts"""
        task = CronTask(
            task_id=self._generate_task_id(TaskType.GENERATE_INSIGHTS),
            task_type=TaskType.GENERATE_INSIGHTS,
            started_at=datetime.now().isoformat()
        )

        try:
            user_volume = self._volumes.get("user")
            if not user_volume:
                task.status = "failed"
                task.summary = "No user volume available"
                return task

            # Get artifact counts
            stats = user_volume.get_stats()

            # Generate insights based on stats
            insights = []

            if stats.trace_count > 100:
                insight = Insight(
                    insight_id=f"insight_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    insight_type="optimization",
                    title="High Trace Count",
                    description=f"You have {stats.trace_count} traces. Consider summarizing old traces to improve performance.",
                    evidence=[],
                    confidence=0.8,
                    actionable=True,
                    suggested_action="Run trace summarization to consolidate old traces."
                )
                insights.append(insight)

                # Save insight to volume
                user_volume.write_artifact(
                    artifact_type=ArtifactType.INSIGHT,
                    artifact_id=insight.insight_id,
                    content=insight.to_markdown(),
                    reason="Generated by UserCron analysis",
                    cron_level="user",
                    is_new=True
                )
                task.artifacts_created += 1

                # Record to observability hub
                if self.observability_hub:
                    self.observability_hub.record_insight(
                        self.cron_id,
                        insight.title,
                        insight.description,
                        "user"
                    )
                    self.observability_hub.record_artifact_created(
                        self.cron_id,
                        "insight",
                        insight.insight_id,
                        "user",
                        f"Generated insight: {insight.title}"
                    )

            task.status = "completed"
            task.summary = f"Generated {len(insights)} insights"
            task.details = {"insight_ids": [i.insight_id for i in insights]}

        except Exception as e:
            task.status = "failed"
            task.summary = str(e)

        task.completed_at = datetime.now().isoformat()
        return task

    async def _suggest_improvements(self) -> CronTask:
        """Suggest improvements based on user's usage patterns"""
        task = CronTask(
            task_id=self._generate_task_id(TaskType.SUGGEST_IMPROVEMENTS),
            task_type=TaskType.SUGGEST_IMPROVEMENTS,
            started_at=datetime.now().isoformat()
        )

        try:
            user_volume = self._volumes.get("user")
            if not user_volume:
                task.status = "failed"
                task.summary = "No user volume available"
                return task

            suggestions = []

            # Check for tools that could be created
            traces = user_volume.list_artifacts(ArtifactType.TRACE)
            tools = user_volume.list_artifacts(ArtifactType.TOOL)

            if len(traces) > 10 and len(tools) == 0:
                suggestion = Suggestion(
                    suggestion_id=f"suggestion_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    suggestion_type="new_tool",
                    title="Create Your First Tool",
                    description="You have traces but no tools. Consider crystallizing a frequently used pattern into a tool.",
                    priority=0.7,
                    estimated_benefit="Faster execution for repeated tasks",
                    implementation_hint="Look at your most successful traces and extract common patterns."
                )
                suggestions.append(suggestion)

                user_volume.write_artifact(
                    artifact_type=ArtifactType.SUGGESTION,
                    artifact_id=suggestion.suggestion_id,
                    content=suggestion.to_markdown(),
                    reason="Generated by UserCron analysis",
                    cron_level="user",
                    is_new=True
                )
                task.artifacts_created += 1

                # Create notification
                self._create_notification(
                    title="New Suggestion Available",
                    message=suggestion.title,
                    importance="suggestion",
                    related_artifacts=[suggestion.suggestion_id]
                )

                # Record to observability hub
                if self.observability_hub:
                    self.observability_hub.record_suggestion(
                        self.cron_id,
                        suggestion.title,
                        suggestion.description,
                        "user"
                    )
                    self.observability_hub.record_artifact_created(
                        self.cron_id,
                        "suggestion",
                        suggestion.suggestion_id,
                        "user",
                        f"Generated suggestion: {suggestion.title}"
                    )

            task.status = "completed"
            task.summary = f"Generated {len(suggestions)} suggestions"

        except Exception as e:
            task.status = "failed"
            task.summary = str(e)

        task.completed_at = datetime.now().isoformat()
        return task


class TeamCron(SentienceCron):
    """
    Team-level sentience cron.

    Access:
    - Read/Write: Team volume
    - Read: System volume (for global patterns)

    Responsibilities:
    - Aggregate insights from team members
    - Identify team-wide patterns
    - Promote successful user artifacts to team level
    - Coordinate team-level improvements
    """

    def __init__(
        self,
        team_id: str,
        volume_manager: VolumeManager,
        schedule_interval_secs: float = 3600.0,  # 1 hour
        llm_callback: Optional[Callable[[str], str]] = None,
        observability_hub: Optional[ObservabilityHub] = None
    ):
        super().__init__(
            cron_level=CronLevel.TEAM,
            owner_id=team_id,
            volume_manager=volume_manager,
            schedule_interval_secs=schedule_interval_secs,
            llm_callback=llm_callback,
            observability_hub=observability_hub
        )
        self.team_id = team_id

    def _setup_volumes(self):
        """Set up team and system volumes"""
        self._volumes = self.volume_manager.get_volumes_for_cron(
            cron_level="team",
            team_id=self.team_id
        )

    async def _run_analysis(self) -> List[CronTask]:
        """Run team-level analysis"""
        tasks = []

        # Task 1: Analyze team patterns
        task = await self._analyze_team_patterns()
        tasks.append(task)

        # Task 2: Look for promotion candidates
        task = await self._identify_promotion_candidates()
        tasks.append(task)

        return tasks

    async def _analyze_team_patterns(self) -> CronTask:
        """Analyze patterns across team artifacts"""
        task = CronTask(
            task_id=self._generate_task_id(TaskType.ANALYZE_TRACES),
            task_type=TaskType.ANALYZE_TRACES,
            started_at=datetime.now().isoformat()
        )

        try:
            team_volume = self._volumes.get("team")
            if not team_volume:
                task.status = "failed"
                task.summary = "No team volume available"
                return task

            stats = team_volume.get_stats()
            task.artifacts_processed = stats.trace_count + stats.tool_count + stats.agent_count

            task.status = "completed"
            task.summary = f"Analyzed team artifacts: {stats.trace_count} traces, {stats.tool_count} tools, {stats.agent_count} agents"

        except Exception as e:
            task.status = "failed"
            task.summary = str(e)

        task.completed_at = datetime.now().isoformat()
        return task

    async def _identify_promotion_candidates(self) -> CronTask:
        """Identify artifacts that should be promoted to system level"""
        task = CronTask(
            task_id=self._generate_task_id(TaskType.PROMOTE_ARTIFACTS),
            task_type=TaskType.PROMOTE_ARTIFACTS,
            started_at=datetime.now().isoformat()
        )

        try:
            team_volume = self._volumes.get("team")
            if not team_volume:
                task.status = "failed"
                task.summary = "No team volume available"
                return task

            # Look for highly-used tools that could benefit all teams
            tools = team_volume.list_artifacts(ArtifactType.TOOL)
            candidates = []

            for tool_id in tools:
                # In production, would check usage stats
                # For now, just identify as candidates
                candidates.append(tool_id)

            task.status = "completed"
            task.summary = f"Found {len(candidates)} promotion candidates"
            task.details = {"candidates": candidates[:5]}

        except Exception as e:
            task.status = "failed"
            task.summary = str(e)

        task.completed_at = datetime.now().isoformat()
        return task


class SystemCron(SentienceCron):
    """
    System-level sentience cron.

    Access:
    - Read/Write: All volumes (system, team, user)

    Responsibilities:
    - Global pattern analysis across all volumes
    - Control and coordinate team/user crons
    - System-wide optimization
    - Promote artifacts from team to system level
    - Cleanup and maintenance
    """

    def __init__(
        self,
        volume_manager: VolumeManager,
        schedule_interval_secs: float = 7200.0,  # 2 hours
        llm_callback: Optional[Callable[[str], str]] = None,
        observability_hub: Optional[ObservabilityHub] = None
    ):
        super().__init__(
            cron_level=CronLevel.SYSTEM,
            owner_id="system",
            volume_manager=volume_manager,
            schedule_interval_secs=schedule_interval_secs,
            llm_callback=llm_callback,
            observability_hub=observability_hub
        )

        # Child crons managed by system
        self._team_crons: Dict[str, TeamCron] = {}
        self._user_crons: Dict[str, UserCron] = {}

    def _setup_volumes(self):
        """Set up access to all volumes"""
        self._volumes = self.volume_manager.get_volumes_for_cron(cron_level="system")

    async def _run_analysis(self) -> List[CronTask]:
        """Run system-level analysis"""
        tasks = []

        # Task 1: Global analysis
        task = await self._analyze_global_patterns()
        tasks.append(task)

        # Task 2: Coordinate child crons
        task = await self._coordinate_child_crons()
        tasks.append(task)

        # Task 3: System maintenance
        task = await self._system_maintenance()
        tasks.append(task)

        return tasks

    async def _analyze_global_patterns(self) -> CronTask:
        """Analyze patterns across all volumes"""
        task = CronTask(
            task_id=self._generate_task_id(TaskType.ANALYZE_TRACES),
            task_type=TaskType.ANALYZE_TRACES,
            started_at=datetime.now().isoformat()
        )

        try:
            total_traces = 0
            total_tools = 0
            total_agents = 0

            for volume_key, volume in self._volumes.items():
                stats = volume.get_stats()
                total_traces += stats.trace_count
                total_tools += stats.tool_count
                total_agents += stats.agent_count

            task.artifacts_processed = total_traces + total_tools + total_agents
            task.status = "completed"
            task.summary = f"Global analysis: {total_traces} traces, {total_tools} tools, {total_agents} agents"

        except Exception as e:
            task.status = "failed"
            task.summary = str(e)

        task.completed_at = datetime.now().isoformat()
        return task

    async def _coordinate_child_crons(self) -> CronTask:
        """Coordinate team and user crons"""
        task = CronTask(
            task_id=self._generate_task_id(TaskType.GENERATE_INSIGHTS),
            task_type=TaskType.GENERATE_INSIGHTS,
            started_at=datetime.now().isoformat()
        )

        try:
            # Ensure team crons exist for all teams
            for team_id in self.volume_manager.list_teams():
                if team_id not in self._team_crons:
                    self._team_crons[team_id] = TeamCron(
                        team_id=team_id,
                        volume_manager=self.volume_manager,
                        llm_callback=self.llm_callback,
                        observability_hub=self.observability_hub
                    )

            task.status = "completed"
            task.summary = f"Managing {len(self._team_crons)} team crons, {len(self._user_crons)} user crons"

        except Exception as e:
            task.status = "failed"
            task.summary = str(e)

        task.completed_at = datetime.now().isoformat()
        return task

    async def _system_maintenance(self) -> CronTask:
        """Perform system maintenance tasks"""
        task = CronTask(
            task_id=self._generate_task_id(TaskType.CLEANUP_OLD_ARTIFACTS),
            task_type=TaskType.CLEANUP_OLD_ARTIFACTS,
            started_at=datetime.now().isoformat()
        )

        try:
            # Would perform cleanup, consolidation, etc.
            task.status = "completed"
            task.summary = "System maintenance completed"

        except Exception as e:
            task.status = "failed"
            task.summary = str(e)

        task.completed_at = datetime.now().isoformat()
        return task

    # =========================================================================
    # CHILD CRON MANAGEMENT
    # =========================================================================

    def register_user_cron(self, user_id: str, team_id: Optional[str] = None) -> UserCron:
        """Register and return a user cron"""
        if user_id not in self._user_crons:
            self._user_crons[user_id] = UserCron(
                user_id=user_id,
                team_id=team_id,
                volume_manager=self.volume_manager,
                llm_callback=self.llm_callback,
                observability_hub=self.observability_hub
            )
        return self._user_crons[user_id]

    def get_user_cron(self, user_id: str) -> Optional[UserCron]:
        """Get a user's cron"""
        return self._user_crons.get(user_id)

    def get_team_cron(self, team_id: str) -> Optional[TeamCron]:
        """Get a team's cron"""
        return self._team_crons.get(team_id)

    def start_all_crons(self):
        """Start all managed crons"""
        self.start()
        for cron in self._team_crons.values():
            cron.start()
        for cron in self._user_crons.values():
            cron.start()

    def stop_all_crons(self):
        """Stop all managed crons"""
        self.stop()
        for cron in self._team_crons.values():
            cron.stop()
        for cron in self._user_crons.values():
            cron.stop()

    def get_all_notifications(self, limit: int = 100) -> List[Dict[str, Any]]:
        """Get notifications from all crons"""
        all_notifications = []

        # System notifications
        all_notifications.extend(self.get_notifications(limit=limit))

        # Team notifications
        for cron in self._team_crons.values():
            all_notifications.extend(cron.get_notifications(limit=limit))

        # User notifications
        for cron in self._user_crons.values():
            all_notifications.extend(cron.get_notifications(limit=limit))

        # Sort by timestamp and limit
        all_notifications.sort(key=lambda n: n["timestamp"], reverse=True)
        return all_notifications[:limit]

    def get_global_status(self) -> Dict[str, Any]:
        """Get status of all crons in the system"""
        return {
            "system": self.get_status(),
            "teams": {
                team_id: cron.get_status()
                for team_id, cron in self._team_crons.items()
            },
            "users": {
                user_id: cron.get_status()
                for user_id, cron in self._user_crons.items()
            }
        }
